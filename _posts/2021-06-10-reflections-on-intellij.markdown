---
title: Reflections on IntelliJ from a Vim Die-Hard
layout: blog
---

_Note: This piece was originally published on the Librato blog in 2008_

<p>In my work as an Integrations Engineer at Librato, I find myself dabbling in many of our codebases. In the last few months, I’ve worked in Ruby, JavaScript, Python, Go, and Java projects. Having used Vim for over ten years, my instinct was to continue using it when working in all of these projects. It didn’t take long to change my mind, and here is why.</p>
<h3>First Steps</h3>
<p>Using Vim feels to me like speaking a native language. I figured I could configure and modify Vim to the point of being as productive as my Java-writing colleagues are with IntelliJ IDEA. But when said colleagues found out that I was planning to write a guide for how to make a happy Vim setup for working with Java, they rebuffed me: “You should really spend your time learning how to use IntelliJ IDEA.” I was reluctant at first—IDEs feel like big, hulking, slow programs. Besides, I don’t want the editor to do things for me—after all, I can “<a href="https://pragprog.com/book/dnvim2/practical-vim-second-edition">edit text at the speed of thought</a>” with Vim. However, I had to admit that using an IDE has certain advantages.</p>
<h3>Why IDE</h3>
<p>The IDE actually understands my Java code. It can refactor my code, automatically declare things, add missing imports, and so forth. Vim can’t do this (well, not without <a href="https://github.com/ervandew/eclim">calling out to Eclipse</a> behind the scenes). Additionally, the Librato data team possesses a wealth of IntelliJ expertise that I can lean on for support.</p>
<p>So, after installing <a href="https://github.com/JetBrains/ideavim">IdeaVim</a> for Vim emulation, and setting up the <a href="https://github.com/jkaving/intellij-colors-solarized">Solarized light theme</a>, I got started. Here are my impressions.</p>
<h3>Highlights of my experience so far</h3>
<p><img loading="lazy" class="aligncenter size-full wp-image-1188" src="/images/Reflections-1.png" alt="" width="550" height="205" srcset="/images/Reflections-1.png 550w, /images/Reflections-1-300x112.png 300w" sizes="(max-width: 550px) 100vw, 550px" /></p>
<p>In Vim I use <a href="https://kien.github.io/ctrlp.vim/">ctrlp.vim</a> as a fuzzy file finder: type “meastest” and the plugin produces a list of matching files, helping me quickly get to the file MeasuresConverterTest.java. IDEA has something a bit smarter: go to class (⌘O). Unlike a fuzzy file finder, this allows me to find classes or interfaces that are nested within outer classes, even if I don’t know the name of the file they’re contained in.</p>
<h3>Jump to Definition</h3>
<p>Rather than having to set up <a href="http://ctags.sourceforge.net/">exuberant ctags </a>for the project, with IDEA this analysis is done automatically. And thanks to IdeaVim, the standard Vim binding for jumping to definition, ⌃], works as expected. After jumping to a definition, jump back to your previous position with ⌃O (remember “o” for “older”). Jump forwards again with Tab. Although IDEA doesn’t support the full <a href="http://vimdoc.sourceforge.net/htmldoc/motion.html#jumplist">jumplist</a> concept from Vim, this covers most important jumplist use case for navigating a codebase.</p>
<p>Working with Java, where the use of inheritance and interfaces is common, sometimes I want the reverse of “go to definition”: given an interface, jump to a particular implementation. With ctags I’m out of luck here, but IDEA supports this. I’ve mapped g] (a mnemonic for ⌃]) to “Go to implementations”, which opens a menu showing the implementations of an interface.</p>
<p>Another great thing about Jump to definition in IDEA is that, without any additional work on my part, it works with standard library classes and my project’s dependencies. This always requires extra setup work with Vim and ctags.</p>
<h3>The Test Runner</h3>
<p>When running the test suite in a Ruby project, I’m accustomed to seeing the orderly march of dots indicating each (hopefully) passing test. In our Java projects, however, we get reams of text output, with the stacktraces for any failures somewhere in the middle. Running our tests from within IDEA offers one solution to this problem. To set this up, right-click the test/src/java directory in in the project tree, and choose “Run ‘All Tests’”. Subsequently, you can run the suite with ⌃⌘R. Even better, to shorten your feedback cycle, you can re-run only the tests that failed in the last run with ⌘R.</p>
<p><img loading="lazy" class="aligncenter size-full wp-image-1189" src="/images/Reflections-2.png" alt="" width="750" height="132" srcset="/images/Reflections-2.png 750w, /images/Reflections-2-300x53.png 300w" sizes="(max-width: 750px) 100vw, 750px" /></p>
<p>IDEA helps make sense of the test output by breaking down the suite into its hierarchy of classes and test cases. Failures are easy to read, and for assertEquals failures, the built-in diff viewer can be handy. Best of all is the ability to navigate from failure to failure using ⌘⌥↓ and  ⌘⌥↓. As a Vim user, this kind of keyboard navigability is key if I’m going to use a GUI program. The icing on the cake is that this is the same keystroke for navigating through build failures or ‘Find in Path’ (project wide search) results.</p>
<h3>Customizing IdeaVim</h3>
<p>In IDEA, every editor action can be referred to by an ID. With IdeaVim you can view this list by running :actionlist and invoke an action using :action ActionName. For example, to select all text run the $SelectAll action using :action $SelectAll. This makes it easy to create mappings in the Vim way. The implementation for my aforementioned g] shortcut is:</p>
<p>nmap g] :action GotoImplementation&lt;CR&gt;</p>
<p>This means: “in normal mode, when I press g], run the GotoImplementation action (and hit enter).” I add this mapping to ~/.ideavimrc and I’m good to go. Note that IdeaVim doesn’t truly support VimScript, but it emulates it for the purposes of configuring mappings.</p>
<h3>Closing Thoughts</h3>
<p>Getting to know IntelliJ IDEA has been a positive experience. My initial reluctance to use a “heavyweight” tool turned out to be unfounded. While IntelliJ IDEA may use more memory than Vim, in practice I don’t think I’ll be any slower with the IDE, now that I have my footing. While I do think it’s possible to create a <a href="http://www.lucianofiandesio.com/vim-configuration-for-happy-java-coding">powerful and productive Java development environment in the Vim we know and love</a>, getting to that productive place is faster with IDEA and IdeaVim.

